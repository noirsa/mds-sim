---
title: "Lab Assignment 1"
author: "Zheshuo and Geming"
date: "2025-10-05"
output: html_document
---

# ASSIGNMENT 1: GEORGIA HOUSE PRICE

## 0. Before Starting

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # Clear the plots
rm(list=ls()) # Clear the environment
```

We start by loading essential libraries, importing the data, and defining functions to simplify repetitive operations.

```{r}
# Installing dependencies
install.packages("lubridate")
```

```{r include = FALSE}
# Loading libraries
library(moments)
library(car)
library(chemometrics)
library(mice)
library(missMDA)
library(FactoMineR)
library(corrplot)
library(VIM)
library(dplyr)
library(ggplot2)
library(AER)
library(MASS)
library(dplyr)
library(lubridate)
library(stringr)
library(readr)
library(tidyr)
library(tidyselect)
```

```{r}
# Importing the main data of the assignment
georgia <- read.csv("RealEstate_Georgia.csv")
```

The dataset contains 6168 housing ads from different cities in different counties of the Georgia state, there are posts from 2014 to 2021 but majority of data are for 2021. For a fair analysis, the houses that are posted in 2021 are taken into account.

```{r}
# Get the dimension of the dataset
dim(georgia) # 6168 obs + 39 variables
```

```{r}
# Show the name of columns
names(georgia)
```

```{r}
# Check the structure of the dataset
str(georgia)
```

```{r}
# Use summary function to get a fast understanding of the dataset
summary(georgia)
```

```{r}
# Converting the date column to numeric
georgia$datePostedString <- as.Date(georgia$datePostedString, format = "%Y-%m-%d")
georgia$datePostedString <- as.numeric(format(georgia$datePostedString, "%Y"))

```
There are 47 records that were not posted in 2021.
```{r}
# Retain all data have datePostedString == 2021
nrow(georgia) - sum(georgia$datePostedString == "2021")
georgia2021 <- georgia[georgia$datePostedString == 2021,]
```

## 1. Explanatory Data Analysis

In this section, we perform a crucial step in any data science project, especially when preparing data for modeling. A comprehensive descriptive analysis is carried out for each variable, emphasizing their most relevant characteristics. We proceed with a column-by-column examination of the dataset, followed by the generation of a data quality report. Subsequently, we prepare the data for the modeling phase by handling missing values through imputation techniques, removing non-informative variables, and creating new derived features where appropriate.

The function we need for EDA processes
```{r}
# Use given Q1 & Q3 to compute indexes of outliers
calculate_outliers <- function(x) {
  # Check for regular outliers
  Boxplot(x, main = "Boxplot")
  outliers <- boxplot.stats(x)$out

  # Compute quartiles and IQR
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1

  # Define thresholds
  lower_mild <- Q1 - 1.5 * IQR
  upper_mild <- Q3 + 1.5 * IQR
  lower_extreme <- Q1 - 3 * IQR
  upper_extreme <- Q3 + 3 * IQR

  # Identify mild and extreme outliers
  mild_idx <- which((x < lower_mild | x > upper_mild))
  extreme_idx <- which((x < lower_extreme | x > upper_extreme))
  
  # Count
  num_mild <- length(mild_idx)
  num_extreme <- length(extreme_idx)

  abline(h = c(lower_mild, upper_mild), col = "blue", lwd = 2)
  abline(h = c(lower_extreme, upper_extreme), col = "red", lwd = 2)

  # Return the results as a list
  return(list(
    num_mild = num_mild,
    num_extreme = num_extreme,
    mild_indexes = mild_idx,
    extreme_indexes = extreme_idx
  ))
}
```

It is important to note that the explanatory data analysis is conducted exclusively on the training dataset. However, the creation and removal of variables derived from this process also affect the test dataset to ensure consistency across both sets.

Univariate Descriptive Analysis

In this initial phase, we analyze each variable in the dataset, emphasizing their key characteristics. Numeric variables that represent categorical or qualitative concepts are converted into factors, and new features may be created based on existing numerical variables to enhance model performance.

Finally, a comprehensive data quality report is presented, assessing the overall integrity of the dataset and discussing potential implications for the modeling process.


**Variable 1: X.1**

Variable X.1 is a numerical variable with no missing values.
A quick inspection reveals that it serves as a unique identifier for each observation, since the number of unique values equals the total number of rows.
Therefore, this variable does not contain meaningful numerical information for statistical analysis.
Normality and outlier tests were not performed, as the variable is an ID rather than a continuous numeric feature.
It contains no missing values thus imputation is not needed. This variable does not contain any outliers. Interestingly, the maximum value (6468) in the data does not match the number of columns (6168), maybe these ids belong to the observations of the original dataset where rental houses from other states are also stored.

```{r}
# Summary of the column
summary(georgia$X.1)
# Any missing values
sum(is.na(georgia$X.1))
# First five elements
georgia$X.1[1:5]
# Number of unique values
unique_counts<-length(unique(georgia$X.1))
# Verify if all values are unique
unique_counts == nrow(georgia)
```

**Variable 2: X**

X is a numerical variable without missing values. It is very similar to the previous variable in all aspects. Although the range of its values is twice of the previous one ([1,6428] vs [25,13803]).

```{r}
# Summary of the column
summary(georgia$X)
# Any missing values
sum(is.na(georgia$X))
# First five elements
georgia$X[1:5]
# Number of unique values
unique_counts<-length(unique(georgia$X))
# Verify if all values are unique
unique_counts == nrow(georgia)

```

**Variable 3: id**

This categorical variable is suppose to contain the unique identifier of each row.
This variable does not have missing values. However, the number of unique values (5515 levels) do not match with the number of rows (6168 rows), so we can't really use it as an identifier in that regard.
Nonetheless, there is another possibility that the dataset contains duplicated rows. And it happens that our idea's hit the bull's eye, it is true that the rows with the same ids are duplicated, most of their variables are the same with exception of the columns X.1, X and countyId.
However, we also find out that not all rows with the same id are equal in terms of other variables, there are some which are likely to have errors in variables like garageSpaces, hasGarage and so on. But only 25 ids out of 653 duplicated ids show that pattern.

```{r}
# Summary of the column
summary(georgia$id)
# Any missing values
sum(is.na(georgia$id))
# First five elements
georgia$id[1:5]
# Number of unique values
length(unique(georgia$id))

# Get duplicated ids
non_unique_ids <- georgia$id[duplicated(georgia$id)]
length(non_unique_ids)

# Observations with the same id are equal in most of the variables
which(georgia$id == non_unique_ids[1])

# obs 19 vs obs 5718
georgia[c(2975, 4502),]

# Let's try another pair
which(georgia$id == non_unique_ids[2])

# obs 19 vs obs 5718
georgia[c(1212, 4505),]

# Ignore the columsn X.1, X and countyId
ignore_cols <- c("X.1", "X", "countyId")
compare_cols <- setdiff(names(georgia), c(ignore_cols))

# For each duplicated id, check if all its rows are identical
same_rows <- sapply(non_unique_ids, function(idv) {
  sub <- georgia[georgia$id == idv, compare_cols, drop = FALSE]
  # All rows identical if only 1 unique row remains after removing duplicates
  nrow(unique(sub)) == 1
})

# Are all duplicates identical?
all(same_rows) # No

# Show two duplicates with different values in those variables
singular_ids <- names(same_rows)[which(same_rows == FALSE)]
georgia[which(georgia$id == singular_ids[1]),]
georgia[which(georgia$id == singular_ids[2]),]

# Number of singular ids
length(singular_ids)



```

**Variable 4: stateId**

This numerical variable contains the id of the state of the rental house in USA. However, since we only have observations from Georgia state, all these ids are the same (Georgia state's id is 16 for all rows). And it has no missing values.

```{r}
# Summary of the column
summary(georgia$stateId)
# Any missing values
sum(is.na(georgia$stateId))
# First five elements
georgia$stateId[1:5]
# Number of unique values
length(unique(georgia$stateId))

# Check frequency
table(georgia$stateId)

```

**Variable 5: countyId**

This numerical variable contains the id of counties in Georgia state. It has no missing values, and the number of unique values is slightly lower than the number of rows, which suggest some of the counties are used more than once. The data is not normally distributed and there is no presence of outliers.

```{r}
# Summary of the column
summary(georgia$countyId)
# Any missing values
sum(is.na(georgia$countyId))
# First five elements
georgia$countyId[1:5]

# Number of unique values
length(unique(georgia$countyId))

hist(georgia$countyId, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$countyId), sd(georgia$countyId)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sci <- sample(georgia$countyId, 5000)
shapiro.test(sci)

# Boxplot to detect outliers
Boxplot(georgia$countyId)
```

**Variable 6: cityId**

This numerical variable represents the unique identifiers for cities in the state of Georgia. The cityId values range from 0 to 397,383, with 374 unique values. Notably, there are 340 occurrences of the value 0, which might indicate missing data.
```{r}
# Summary of the column
out_ci <- summary(georgia$cityId)
out_ci
# Any missing values
sum(is.na(georgia$cityId))
# First five elements
georgia$cityId[1:5]
# Number of unique values
length(unique(georgia$cityId))

# Check frequency
table(georgia$cityId)

```

**Variable 7: country**

This categorical variable contains the name of the country where the rental houses are found. Each house is geographically located in Georgia, a state in the USA, so its the same value for all the rows. This variable has no missing values.

```{r}
# Summary of the column
summary(georgia$country)
# Any missing values
sum(is.na(georgia$country))
# First five elements
georgia$country[1:5]
# Number of unique values
length(unique(georgia$country))
# Check frequency
table(georgia$country)

```

**Variable 8: datePostedString**

This variable was previously a categorical variable which contains the date when the rental house was published. We performed a conversion at the beginning to keep only the year. This variable has no missing values and most of the houses were posted on 2021, only a small number of them are posted 2020 (47).

```{r}
# Summary of the column
summary(georgia$datePostedString)
# Any missing values
sum(is.na(georgia$datePostedString))
# First five elements
georgia$datePostedString[1:5]
# Number of unique values
length(unique(georgia$datePostedString))

length(which(georgia$datePostedString != 2021))

plot(factor(georgia$datePostedString))
```

**Variable 9: is_bankOwned**

The variable is_bankOwned is a boolean variable that indicates whether the house is offered by a bank. This variable has no missing values and almost no house is owned by a bank, with exception of the observation 158.

```{r}
# Summary of the column
summary(georgia$is_bankOwned)
# Any missing values
sum(is.na(georgia$is_bankOwned))
# First five elements
georgia$is_bankOwned[1:5]
# Number of unique values
length(unique(georgia$is_bankOwned))

length(which(georgia$is_bankOwned != 0))
# Houses owned by a bank
which(georgia$is_bankOwned != 0)

plot(factor(georgia$is_bankOwned))
```

**Variable 10: is_forAuction**

The variable is_forAuction is almost identical to the previous column in terms of labels. It is also a boolean variable that indicates whether the house belongs to an auction. This variable has no missing values and no house is auctioned, with exception of the observation 3946.

```{r}
# Summary of the column
summary(georgia$is_forAuction)
# Any missing values
sum(is.na(georgia$is_forAuction))
# First five elements
georgia$is_forAuction[1:5]
# Number of unique values
length(unique(georgia$is_forAuction))

length(which(georgia$is_forAuction != 0))
# Houses belong to an auction
which(georgia$is_forAuction != 0)

plot(factor(georgia$is_forAuction))
```

**Variable 11: event**

The variable event is a categorical variable with 5 levels that indicates the sales type of each rental house. This variable has no missing values, around 5000 observations have "Listed for sale" and around 1000 have "Price change" in this variable. The rest of the labels have very low presence in the data.

```{r}

# Any missing values
sum(is.na(georgia$event))
# First five elements
georgia$event[1:5]
# Number of unique values
length(unique(georgia$event))

# Convert 'event' to factor for better handling as categorical variable
georgia$event <- factor(georgia$event)
# Summary of the column
summary(georgia$event)
plot(factor(georgia$event))
```

**Variable 12: time**

The time variable is a numerical variable representing the timestamp when each observation was collected. This variable has no missing values and contains 216 unique timestamps. The data was collected after 2021.
```{r}
# Summary of the column
out_ct <- summary(georgia$time)
out_ct
# Any missing values
sum(is.na(georgia$time))
# First five elements
georgia$time[1:5]
# Number of unique values
length(unique(georgia$time))

hist(georgia$time, breaks = 20, freq = F)
# Check for any duplicate timestamps (indicating possible data duplication)
sum(duplicated(georgia$time))  # Count how many duplicate timestamps exist

# convert time stamp to date
dates <- as.POSIXct(georgia$time / 1000, origin = "1970-01-01", tz = "UTC")
dates

```

**Variable 13: price**

The variable price is a numerical variable indicating the price of the rental houses. It ranges from 6,250 USD to 1,300,000 USD. This variable has no missing values and there are 1227 unique values. It's distribution resembles that of a normal distribution, but the Shapiro test says the otherwise. Moreover, there are 43 extreme outliers in the data.

```{r}
# Summary of the column
out_cp <- summary(georgia$price)
out_cp
# Any missing values
sum(is.na(georgia$price))
# First five elements
georgia$price[1:5]
# Number of unique values
length(unique(georgia$price))

hist(georgia$price, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$price), sd(georgia$price)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sp <- sample(georgia$price, 5000)
shapiro.test(sp)

#detect outlier

out <- calculate_outliers(georgia$price)

# Compute number of extreme outliers
out$num_extreme

```

**Variable 14: pricePerSquareFoot**

The variable pricePerSquareFoot is a numerical variable that, as its name indicates, it stores the price per square foot of the rental houses. It ranges from 4.0 sqft to 205.00 sqft. This variable has no missing values and there are 440 unique values. It's not normally distributed and there are some considerably high values that might be errors while collecting the data. Those values are most likely extreme outliers in the data, which are 56.

```{r}
# Summary of the column
out_cppsf <- summary(georgia$pricePerSquareFoot)
out_cppsf
# Any missing values
sum(is.na(georgia$pricePerSquareFoot))
# First five elements
georgia$pricePerSquareFoot[1:5]
# Number of unique values
length(unique(georgia$pricePerSquareFoot))

hist(georgia$pricePerSquareFoot, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$pricePerSquareFoot), sd(georgia$pricePerSquareFoot)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sppsf <- sample(georgia$pricePerSquareFoot, 5000)
shapiro.test(sppsf)

# Boxplot to detect outliers
boxplot(georgia$pricePerSquareFoot)

# Outliers
iqr_ppsf <- out_cppsf[5] - out_cppsf[2]
mild_lower <- out_cppsf[2] - 1.5 * iqr_ppsf
mild_upper <- out_cppsf[5] + 1.5 * iqr_ppsf
extreme_lower <- out_cppsf[2] - 3 * iqr_ppsf
extreme_upper <- out_cppsf[5] + 3 * iqr_ppsf

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$pricePerSquareFoot < extreme_lower | georgia$pricePerSquareFoot > extreme_upper))

num_extreme
```

**Variable 15: city**

The variable city is a categorical variable indicating the name of the city where the houses are located in. There are no missing data in the data and it has 383 unique values in this column. The most frequent city that appears in this data is Atlanta, followed by Marietta, Augusta, Columbus and Macon.

```{r}
# Summary of the column
summary(georgia$city)
# Any missing values
sum(is.na(georgia$city))
# First five elements
georgia$city[1:5]
# Number of unique values
length(unique(georgia$city))

plot(factor(georgia$city))
sort(table(georgia$city), decreasing = TRUE)[1:5]
```

**Variable 16: state**

This categorical variable contains the name of the state where the rental houses are found. Each house is geographically located in Georgia, so in this field we only have one value, which is Georgia, represented by GA. This variable has no missing values.

```{r}
# Summary of the column
summary(georgia$state)
# Any missing values
sum(is.na(georgia$state))
# First five elements
georgia$state[1:5]
# Number of unique values
length(unique(georgia$state))
```

**Variable 17: yearBuilt**

The variable yearBuilt is a numerical variable indicating the year when the house was built. This variable has no missing values and there are 159 unique values. It's proved by the Shapiro test that it is not normally distributed and there are 16 extreme outliers. Those outliers are irreal, the maximum value of the data is 9999.

```{r}
# Summary of the column
out_cyb <- summary(georgia$yearBuilt)
out_cyb
# Any missing values
sum(is.na(georgia$yearBuilt))
# First five elements
georgia$yearBuilt[1:5]
# Number of unique values
length(unique(georgia$yearBuilt))

hist(georgia$yearBuilt, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$yearBuilt), sd(georgia$yearBuilt)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
syb <- sample(georgia$yearBuilt, 5000)
shapiro.test(syb)

# Boxplot to detect outliers
boxplot(georgia$yearBuilt)

# Outliers
iqr_yb <- out_cyb[5] - out_cyb[2]
mild_lower <- out_cyb[2] - 1.5 * iqr_yb
mild_upper <- out_cyb[5] + 1.5 * iqr_yb
extreme_lower <- out_cyb[2] - 3 * iqr_yb
extreme_upper <- out_cyb[5] + 3 * iqr_yb

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$yearBuilt < extreme_lower | georgia$yearBuilt > extreme_upper))

num_extreme
```

**Variable 18: streetAddress**

This categorical variable contains the street address of the rental houses. There are no missing values and there are 5514 levels, meaning some houses are geographically located in the same street.

```{r}
# Summary of the column
summary(georgia$streetAddress)
# Any missing values
sum(is.na(georgia$streetAddress))
# First five elements
georgia$streetAddress[1:5]
# Number of unique values
length(unique(georgia$streetAddress))
```

**Variable 19: zipcode**

Zipcode is a numerical variable containing the zipcode of each rental house. There are no missing values and there are 446 unique numerical values. The data is not normally distributed (confirmed by the Shapiro test). In this case we do not have any extreme outliers, but we do have 331 mild outliers.

```{r}
# Summary of the column
out_czc <- summary(georgia$zipcode)
out_czc
# Any missing values
sum(is.na(georgia$zipcode))
# First five elements
georgia$zipcode[1:5]
# Number of unique values
length(unique(georgia$zipcode))

hist(georgia$zipcode, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$zipcode), sd(georgia$zipcode)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
szc <- sample(georgia$zipcode, 5000)
shapiro.test(szc)

# Boxplot to detect outliers
boxplot(georgia$zipcode)

# Outliers
iqr_yzc <- out_czc[5] - out_czc[2]
mild_lower <- out_czc[2] - 1.5 * iqr_yzc
mild_upper <- out_czc[5] + 1.5 * iqr_yzc
extreme_lower <- out_czc[2] - 3 * iqr_yzc
extreme_upper <- out_czc[5] + 3 * iqr_yzc

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of mild outliers
num_mild <- length(which(georgia$zipcode < mild_lower | georgia$zipcode > mild_upper))

num_mild
```

**Variable 20: longitude**

The numerical variable longitude contains the longitude of each of the rental houses. There are no missing values and there are 5437 unique numerical values. The data is not normally distributed (confirmed by the Shapiro test) and ranges from -85.57 to -80.97. In addition, there are 97 extreme outliers.

```{r}
# Summary of the column
out_clg <- summary(georgia$longitude)
out_clg
# Any missing values
sum(is.na(georgia$longitude))
# First five elements
georgia$longitude[1:5]
# Number of unique values
length(unique(georgia$longitude))

hist(georgia$longitude, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$longitude), sd(georgia$longitude)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
slg <- sample(georgia$longitude, 5000)
shapiro.test(slg)

# Boxplot to detect outliers
boxplot(georgia$longitude)

# Outliers
iqr_ylg <- out_clg[5] - out_clg[2]
mild_lower <- out_clg[2] - 1.5 * iqr_ylg
mild_upper <- out_clg[5] + 1.5 * iqr_ylg
extreme_lower <- out_clg[2] - 3 * iqr_ylg
extreme_upper <- out_clg[5] + 3 * iqr_ylg

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$longitude < extreme_lower | georgia$longitude > extreme_upper))

num_extreme
```

**Variable 21: latitude**

The numerical variable latitude contains the latitude of each of the rental houses. There are no missing values and there are 5455 unique numerical values. The data is not normally distributed (confirmed by the Shapiro test) and ranges from 30.73 to 34.99. In addition, there are 82 extreme outliers.

```{r}
# Summary of the column
out_clt <- summary(georgia$latitude)
out_clt
# Any missing values
sum(is.na(georgia$latitude))
# First five elements
georgia$latitude[1:5]
# Number of unique values
length(unique(georgia$latitude))

hist(georgia$latitude, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$latitude), sd(georgia$latitude)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
slt <- sample(georgia$latitude, 5000)
shapiro.test(slt)

# Boxplot to detect outliers
boxplot(georgia$latitude)

# Outliers
iqr_ylt <- out_clt[5] - out_clt[2]
mild_lower <- out_clt[2] - 1.5 * iqr_ylt
mild_upper <- out_clt[5] + 1.5 * iqr_ylt
extreme_lower <- out_clt[2] - 3 * iqr_ylt
extreme_upper <- out_clt[5] + 3 * iqr_ylt

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$latitude < extreme_lower | georgia$latitude > extreme_upper))

num_extreme
```

**Variable 22: hasBadGeocode**

This boolean variable indicates whether a row has bad geocode. Geocode allows we to take each observation's information and create a map of their locations. There are no missing values in the data, but there are only 0s thoughout the column, in other words, there are no observation with bad geocode, since we can determine the location of each house using the longitude and latitude columns in the dataset.

```{r}
# Summary of the column
summary(georgia$hasBadGeocode)
# Any missing values
sum(is.na(georgia$hasBadGeocode))
# First five elements
georgia$hasBadGeocode[1:5]
# Number of unique values
length(unique(georgia$hasBadGeocode))

hist(georgia$hasBadGeocode, breaks = 20, freq = F)
```

**Variable 23: description**

This categorical variable contains a textual description provided by the sellers of the rental houses. There are no missing values in the data, but not all descriptions are unique (unique values = 5429), there are some rows that share the same descriptions. This reminds us of the analysis we did with the variable 3: id. We found out that there are some observations with the same observations are equal in most of the variables, but there are some that do not follow that pattern. Maybe the sellers were so lazy that they copied and pasted one of the description they had on their hand on similar rental houses' posts.

```{r}
# Summary of the column
summary(georgia$description)
# Any missing values
sum(is.na(georgia$description))
# First five elements
georgia$description[1]
# Number of unique values
length(unique(georgia$description))

# Get duplicated descriptions
duplicated_descriptions <- georgia[duplicated(georgia$description) | duplicated(georgia$description, fromLast = TRUE), ]

# Some observations with the same description are equal in most of the variables
which(georgia$description == duplicated_descriptions$description[1])

# obs 19 vs obs 5718
georgia[c(19, 5718),]

# Not all observations with the same description are equal
which(georgia$description == duplicated_descriptions$description[6])

# obs 60 vs obs 174
georgia[c(60, 174),]
```

**Variable 24: currency**

This categorical variable contains the currency used in each of the observations. However, since we only have observations from Georgia state, the currency in each row is USA. And it has no missing values.

```{r}
# Summary of the column
summary(georgia$currency)
# Any missing values
sum(is.na(georgia$currency))
# First five elements
georgia$currency[1:5]
# Number of unique values
length(unique(georgia$currency))
```

**Variable 25: livingArea**

This numerical variable contains the living are of the rental houses in sqft. There are no missing values and it's not normally distributed. There are in total 2601 unique values in the data. In addition, 9 extreme outliers are found, each of them are above 7000 sqft.

```{r}
# Summary of the column
out_cla <- summary(georgia$livingArea)
out_cla
# Any missing values
sum(is.na(georgia$livingArea))
# First five elements
georgia$livingArea[1:5]
# Number of unique values
length(unique(georgia$livingArea))

hist(georgia$livingArea, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$livingArea), sd(georgia$livingArea)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sla <- sample(georgia$livingArea, 5000)
shapiro.test(sla)

# Boxplot to detect outliers
boxplot(georgia$livingArea)

# Outliers
iqr_yla <- out_cla[5] - out_cla[2]
mild_lower <- out_cla[2] - 1.5 * iqr_yla
mild_upper <- out_cla[5] + 1.5 * iqr_yla
extreme_lower <- out_cla[2] - 3 * iqr_yla
extreme_upper <- out_cla[5] + 3 * iqr_yla

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$livingArea < extreme_lower | georgia$livingArea > extreme_upper))

num_extreme
```

**Variable 26: livingAreaValue**

This numerical variable contains exactly the same values as the previous one, they are actually the same columns with a different column name.

```{r}
# Whether these two columns are equal
all(georgia$livingArea == georgia$livingAreaValue)
```
**Variable 27: bathrooms**

This numerical variable indicates the number of bathrooms each one of the rental houses has. There are no missing values and it's not normally distributed. Thre are 11 unique values and 35 extreme outliers (> 6 bathrooms).

```{r}
# Summary of the column
out_cb <- summary(georgia$bathrooms)
out_cb
# Any missing values
sum(is.na(georgia$bathrooms))
# First five elements
georgia$bathrooms[1:5]
# Number of unique values
length(unique(georgia$bathrooms))

hist(georgia$bathrooms, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$bathrooms), sd(georgia$bathrooms)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sb <- sample(georgia$bathrooms, 5000)
shapiro.test(sb)

# Boxplot to detect outliers
boxplot(georgia$bathrooms)

# Outliers
iqr_yb <- out_cb[5] - out_cb[2]
mild_lower <- out_cb[2] - 1.5 * iqr_yb
mild_upper <- out_cb[5] + 1.5 * iqr_yb
extreme_lower <- out_cb[2] - 3 * iqr_yb
extreme_upper <- out_cb[5] + 3 * iqr_yb

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$bathrooms < extreme_lower | georgia$bathrooms > extreme_upper))

num_extreme
```

**Variable 28: bedrooms**

This numerical variable indicates the number of bedrooms each one of the rental houses has. There are no missing values and it's not normally distributed. Thre are 12 unique values and 18 extreme outliers (> 7 bedrooms).

```{r}
# Summary of the column
out_cbd <- summary(georgia$bedrooms)
out_cbd
# Any missing values
sum(is.na(georgia$bedrooms))
# First five elements
georgia$bedrooms[1:5]
# Number of unique values
length(unique(georgia$bedrooms))

hist(georgia$bedrooms, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$bedrooms), sd(georgia$bedrooms)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sbd <- sample(georgia$bedrooms, 5000)
shapiro.test(sbd)

# Boxplot to detect outliers
boxplot(georgia$bedrooms)

# Outliers
iqr_ybd <- out_cbd[5] - out_cbd[2]
mild_lower <- out_cbd[2] - 1.5 * iqr_ybd
mild_upper <- out_cbd[5] + 1.5 * iqr_ybd
extreme_lower <- out_cbd[2] - 3 * iqr_ybd
extreme_upper <- out_cbd[5] + 3 * iqr_ybd

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of extreme outliers
num_extreme <- length(which(georgia$bedrooms < extreme_lower | georgia$bedrooms > extreme_upper))

num_extreme
```

**Variable 29: buildingArea**

This numerical variable contains exactly the same values as the variables 24 and 25 (livingArea and livingAreaValue), they are actually the same columns with a different column name.

```{r}
# Whether these two columns are equal
all(georgia$livingAreaValue == georgia$buildingArea)
```

**Variable 30: parking**

The variable parking is a boolean variable that indicates whether the house offers parking. This variable has no missing values. The number of houses with parking (4711) exceeds the number of those which have not (1457).

```{r}
# Summary of the column
summary(georgia$parking)
# Any missing values
sum(is.na(georgia$parking))
# First five elements
georgia$parking[1:5]
# Number of unique values
length(unique(georgia$parking))

plot(factor(georgia$parking))
```

**Variable 31: garageSpaces**

The variable garageSpaces is a numerical variable that indicates the number of garage spaces in the house. This variable has no missing values and there are 8 unique values from 0 to 7. It's not normally distributed and there are no extreme outliers, but it has 5 mild outliers (> 5 garage spaces).

```{r}
# Summary of the column
out_cgs <- summary(georgia$garageSpaces)
out_cgs
# Any missing values
sum(is.na(georgia$garageSpaces))
# First five elements
georgia$garageSpaces[1:5]
# Number of unique values
length(unique(georgia$garageSpaces))

hist(georgia$garageSpaces, breaks = 20, freq = F)
curve(dnorm(x, mean(georgia$garageSpaces), sd(georgia$garageSpaces)), add = T)

# Shapiro test only accepts sample sizes between 3 and 5000
sgs <- sample(georgia$garageSpaces, 5000)
shapiro.test(sgs)

# Boxplot to detect outliers
boxplot(georgia$garageSpaces)

# Outliers
iqr_ygs <- out_cgs[5] - out_cgs[2]
mild_lower <- out_cgs[2] - 1.5 * iqr_ygs
mild_upper <- out_cgs[5] + 1.5 * iqr_ygs
extreme_lower <- out_cgs[2] - 3 * iqr_ygs
extreme_upper <- out_cgs[5] + 3 * iqr_ygs

abline(h = c(mild_lower, mild_upper), col = "blue", lwd = 2)
abline(h = c(extreme_lower, extreme_upper), col = "red", lwd = 2)

# Compute number of mild outliers
num_mild <- length(which(georgia$garageSpaces < mild_lower | georgia$garageSpaces > mild_upper))

num_mild
```

**Variable 32: hasGarage**

The variable hasGarage is a boolean variable that indicates whether the house has a garage. This variable has no missing values. The number of houses with a garage (3821) exceeds the number of those which have not (2347).

```{r}
# Summary of the column
summary(georgia$hasGarage)
# Any missing values
sum(is.na(georgia$hasGarage))
# First five elements
georgia$hasGarage[1:5]
# Number of unique values
length(unique(georgia$hasGarage))

plot(factor(georgia$hasGarage))

# Is there a house where the variable hasGarage is 0 and there are more than 0 garageSpaces?
which(georgia$garageSpaces > 0 & georgia$hasGarage == 0)
```

**Variable 33: levels**

The variable levels is a categorical variable that indicates the levels of the buildings. This variable has no missing values and it has 35 unique values. However, this variable is a bit messy, there are a lot of repeated labels, they may be written differently, but in fact, they have the same meaning. For instance, the label "3 Story" matches with "Tri-level".

```{r}
# Summary of the column
summary(georgia$levels)
# Any missing values
sum(is.na(georgia$levels))
# First five elements
georgia$levels[1:5]
# Number of unique values
length(unique(georgia$levels))

# Show all levels
unique(georgia$levels)
```

**Variable 34: pool**

The variable pool is a boolean variable that indicates whether the house has a pool This variable has no missing values. Only 438 observations out of 6168 have a pool.

```{r}
# Summary of the column
summary(georgia$pool)
# Any missing values
sum(is.na(georgia$pool))
# First five elements
georgia$pool[1:5]
# Number of unique values
length(unique(georgia$pool))

plot(factor(georgia$pool))

# Number of houses with pool
length(which(georgia$pool == 1))
```

**Variable 35: spa**

The variable spa is a boolean variable that indicates whether the house has spa This variable has no missing values. Only 644 observations out of 6168 have spa.

```{r}
# Summary of the column
summary(georgia$spa)
# Any missing values
sum(is.na(georgia$spa))
# First five elements
georgia$spa[1:5]
# Number of unique values
length(unique(georgia$spa))

plot(factor(georgia$spa))

# Number of houses with spa
length(which(georgia$spa == 1))
```

**Variable 36: isNewConstruction**

The variable isNewConstruction is a boolean variable that indicates whether a rental house is a new building. There are no missing values and only 388 observations out of 6168 are new.

```{r}
# Summary of the column
summary(georgia$isNewConstruction)
# Any missing values
sum(is.na(georgia$isNewConstruction))
# First five elements
georgia$isNewConstruction[1:5]
# Number of unique values
length(unique(georgia$isNewConstruction))

plot(factor(georgia$isNewConstruction))

# Number of new constructed houses
length(which(georgia$isNewConstruction == 1))
```

**Variable 37: hasPetsAllowed**

The variable hasPetsAllowed is a boolean variable that indicates whether it is allowed to have pets in the rental houses. There are no missing values and only 51 houses out of 6168 allow pets.

```{r}
# Summary of the column
summary(georgia$hasPetsAllowed)
# Any missing values
sum(is.na(georgia$hasPetsAllowed))
# First five elements
georgia$hasPetsAllowed[1:5]
# Number of unique values
length(unique(georgia$hasPetsAllowed))

plot(factor(georgia$hasPetsAllowed), )

# Number of pets allowing houses
length(which(georgia$hasPetsAllowed == 1))
```

**Variable 38: homeType**

The variable homeType is a categorical variable that indicates the type of the rental houses. This variable has 5 unique values and there are no missing values. The type "SINGLE_FAMILY" is predominant in the data, the rest of the labels have low presence throughout the data.

```{r}
# Summary of the column
summary(georgia$homeType)
# Any missing values
sum(is.na(georgia$homeType))
# First five elements
georgia$homeType[1:5]
# Number of unique values
length(unique(georgia$homeType))

plot(factor(georgia$homeType))
```

**Variable 39: county**

The variable county is a categorical variable that indicates the county in Georgia state where the building is located. This variable has 129 unique values and there are no missing values.

```{r}
# Summary of the column
summary(georgia$county)
# Any missing values
sum(is.na(georgia$county))
# First five elements
georgia$county[1:5]
# Number of unique values
length(unique(georgia$county))
```

## Data quality reports

**Variables**

Up to this points, all variables in the dataset have been explored. In terms of missingness, no missing data are found in the dataset. Although the proportions of categories in some of the variables are just too exaggerated, it might yield better results if we removed those columns. If we rank the numeric variables in terms of 
number of outliers, the following list is obtained, starting with the most outliers: longitude (97 extreme outliers), latitude (82 extreme outliers), pricePerSquareFoot (56 extreme outliers), price (43 extreme outliers), bathrooms (35 extreme outliers), bedrooms (18 extreme outliers), yearBuilt (16 extreme outliers), livingArea (9 extreme outliers), zipcode (331 mild outliers) and garageSpaces (5 mild outliers).
 
**Univariate Analisis**

Now we will study the univariate outliers of the aforementioned variables.




First the number of univariate outliers per 
individual are counted and added in a new variable called ‘univ_outl_count’. Looking 
at the 8 individuals with the most univariate outliers (4) it can be concluded that they 
are all old, highly taxed, low mpg, high engine size and most with a low price and high 
mileage. A correlation matrix confirms this as it shows a significant negative 
correlation to the year (so the older the car, the more univ outliers) and a significant 
positive correlation to both mileage and engine size. 

















## Data Cleaning

```{r}
# We store the cleaned version of the data here
filtered_georgia <- georgia
```

```{r}
# First, let's check if there is any missing values in the datase
sum(is.na(georgia)) # There are no NAs in the dataset
```

```{r}
# Next, we should filter and remove all observations that were not posted in 2021 and some validation based on common sense like bathrooms and bedrooms should be higher than 0.
georgia_2021_only <- georgia %>%
  filter(year(datePostedString) == 2021) %>%
  distinct() # Retain unique rows

# While there are obs where the number of bathrooms and bedrooms is 0, there are no obs where the price is lower o equal to 0: length(which(georgia$price > 0)) == 6168

# After applying this filter, the new number of rows is 6097

```

```{r}
# Interestingly, the column id does not have the same number of unique values as the number of obs.
nrow(georgia_2021_only) == length(unique(georgia_2021_only$id)) # 6097 vs 5448

# On the other hand, the columns X.1 and X have the exact number of unique values as rows
length(unique(georgia_2021_only$X.1)) # 6097
length(unique(georgia_2021_only$X)) # 6098

# Since the columns X.1 and X do not provide any relevant information, we are just going to concatenate them to the tail of the column id, so it will have a unique value for every obs. Although the id itself is neither useful, we can still use it to identify the observations.
georgia_2021_only$id_unique <- paste0(georgia_2021_only$id, "_", 
                                      georgia_2021_only$X.1, "_", 
                                      georgia_2021_only$X)

# Move id_unique to the front and drop the old columns
georgia_2021_only <-
  georgia_2021_only[, c(ncol(georgia_2021_only), 1:ncol(georgia_2021_only)-1)]
georgia_2021_only$X.1 <- NULL
georgia_2021_only$X <- NULL
georgia_2021_only$id <- NULL

```

```{r}
# Let's check if there are columns that have only one value across the dataset
sapply(georgia_2021_only,n_distinct)

# Note that stateId, country, state, hasBadGeoCode and currency only have one factor throughout the dataset (16, USA, GA, 0, USD). These columns do not provide anything to the posterior analysis, so they should be eliminated. The following line removes all constant columns.
georgia_value_rem <- georgia_2021_only[,
              sapply(georgia_2021_only, function(x) length(unique(x)) > 1)]

```

```{r}
# We found that the columns is_bankOwned and is_forAuction only have one positive case for each of them in the filtered dataset. We should also remove these columns, since 99% of the rows have 0 in these two columns.
sum(georgia_value_rem$is_forAuction == 1)
#georgia_value_rem[which(georgia_value_rem$is_bankOwned == 1),]
sum(georgia_value_rem$is_bankOwned == 1)
#georgia_value_rem[which(georgia_value_rem$is_forAuction == 1),]

# Remove columns
georgia_value_rem$is_bankOwned <- NULL
georgia_value_rem$is_forAuction <- NULL
```

```{r}
# In the city column there are some factors registered in uppercase, we can also remove white spaces that might appear at the beginning and the end of each city.
unique(factor(georgia_value_rem$city))[293] # JOHNS CREEK

# The following line corrects that structure error
georgia_value_rem <- georgia_value_rem %>%
  mutate(
    city = city %>% str_trim() %>% str_to_title(),
    # Remove spaces and capitalize the first letter.
)

# Now the number of unique factors reduced from 380 to 370

```

```{r}
# The column levels is messy and not consistent, since it has both numeric and categorical labels
unique(factor(georgia_value_rem$levels))

# We are going to perform an explicit mapping for the 35 observed raw values
mapping <- c(
  "One and One Half"                          = "1.5",
  "One"                                       = "1",
  "Two"                                       = "2",
  "Three Or More"                             = "3+",
  "Multi/Split"                               = "multi",
  "Multi/Split-Split Level"                   = "multi",
  "0"                                         = NA,
  "One-Two Story Foyer"                       = "multi",
  "Tri Level"                                 = "split",
  "2.5 Story"                                 = "2.5",
  "Manufactured Home 1 Story"                 = "manufactured",
  "Two-Split Foyer"                           = "split",
  "One and One Half-Split Level"              = "multi",
  "Split Foyer"                               = "split",
  "One and One Half-Two"                      = "multi",
  "Two-Two Story Foyer"                       = "multi",
  "One and One Half-Multi/Split"              = "multi",
  "Three Or More-Two Story Foyer"             = "3+",
  "One-Two"                                   = "multi",
  "One-One and One Half"                      = "multi",
  "One-Manufactured Home 1 Story"             = "manufactured",
  "Multi/Split-Two"                           = "multi",
  "Two-Multi/Split"                           = "multi",
  "One-Other"                                 = "other",
  "Two-Three Or More"                         = "multi",
  "One-One and One Half-Two"                  = "multi",
  "Three Or More-Split Level-Tri-Level"       = "3+",
  "Two-Foyer - 2 Story"                       = "2",
  "Other-See Remarks"                         = "other",
  "Split Level"                               = "split",
  "3 Story"                                   = "3+",
  "Two-Split Level"                           = "split",
  "One-Mobile Home 1 Story"                   = "manufactured",
  "Tri Level-Split Level"                     = "split",
  "Tri-Level"                                 = "split"
)

# Apply mapping
georgia_value_rem <- georgia_value_rem %>%
  mutate(
    levels = mapping[as.character(levels)],
  )%>%
  filter(!is.na(levels)) # Rental houses with 0 stories are not possible, they need removing

```


```{r}
# which(georgia_2021_only$hasGarage == 1 & georgia_2021_only$garageSpaces == 0) -> is that even possible?
```

```{r}
# There are some columns that do not provide any useful information at all, like description, streetAddress, ... Can we eliminate them?
```


\newpage



## Data quality reports

**Variables**

Up to this points, all variables in the dataset have been explored. In terms of missingness, no missing data are found in the dataset. Although the proportions of categories in some of the variables are just too exaggerated, it might yield better results if we removed those columns. If we rank the numeric variables in terms of 
number of outliers, the following list is obtained, starting with the most outliers: longitude (97 extreme outliers), latitude (82 extreme outliers), pricePerSquareFoot (56 extreme outliers), price (43 extreme outliers), bathrooms (35 extreme outliers), bedrooms (18 extreme outliers), yearBuilt (16 extreme outliers), livingArea (9 extreme outliers), zipcode (331 mild outliers) and garageSpaces (5 mild outliers).
 
**Univariate Analisis**

Now we will study the univariate outliers of the aforementioned variables.
=======




First the number of univariate outliers per 
individual are counted and added in a new variable called ‘univ_outl_count’. Looking 
at the 8 individuals with the most univariate outliers (4) it can be concluded that they 
are all old, highly taxed, low mpg, high engine size and most with a low price and high 
mileage. A correlation matrix confirms this as it shows a significant negative 
correlation to the year (so the older the car, the more univ outliers) and a significant 
positive correlation to both mileage and engine size. 

Price
```{r}
georgia$univ_outl_count <- 0
georgia$univ_outl_count[Boxplot(georgia$price, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$price, id = list(n=Inf))] +1
```
```{r}
georgia$univ_outl_count[Boxplot(georgia$yearBuilt, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$yearBuilt, id = list(n=Inf))] +1
```
```{r}
georgia$univ_outl_count[Boxplot(georgia$latitude, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$latitude, id = list(n=Inf))] +1

```


```{r}
georgia$univ_outl_count[Boxplot(georgia$longitude, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$longitude, id = list(n=Inf))] +1

```

```{r}
georgia$univ_outl_count[Boxplot(georgia$livingArea, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$livingArea, id = list(n=Inf))] +1

```
```{r}
georgia$univ_outl_count[Boxplot(georgia$bathrooms, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$bathrooms, id = list(n=Inf))] +1

```
```{r}
georgia$univ_outl_count[Boxplot(georgia$bedrooms, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$bedrooms, id = list(n=Inf))] +1

```
```{r}
georgia$univ_outl_count[Boxplot(georgia$garageSpaces, id = list(n=Inf))] = georgia$univ_outl_count[Boxplot(georgia$garageSpaces, id = list(n=Inf))] +1
```
```{r}
max(georgia$univ_outl_count)
```
```{r}
georgia[which(georgia$univ_outl_count == 7),]
georgia_interest = georgia[,c(13,17,20,21,25,27,28)]
cor_outl = cor(georgia_interest)
require(corrplot)
par(mfrow=c(1,1))
corrplot(cor_outl, method = 'number')
```


